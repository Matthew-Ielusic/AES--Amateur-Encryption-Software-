
#include "pch.h"
#include "CppUnitTest.h"

#include <vector>

#include "AmateurEncrypt.h"
#include "AmateurDecrypt.h"



using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace Tests
{
	TEST_CLASS(ExportTests)
	{
	public:

		TEST_METHOD(TestEncryptBlock)
		{
			std::vector<uint8_t> key{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
			AmateurEncrypt encrypt(key);

			std::vector<uint8_t> input{ 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 };

			std::vector<uint8_t> actual = encrypt.encryptBlock(input);
			std::vector<uint8_t> repeat = encrypt.encryptBlock(input);

			std::vector<uint8_t> expected = { 0x39, 0x25, 0x84, 0x1d, 0x2, 0xdc, 0x9, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0xb, 0x32 };

			Assert::AreEqual(expected.size(), actual.size());
			Assert::AreEqual(expected.size(), repeat.size());
			for (int i = 0; i < 16; ++i) {
				Assert::AreEqual(expected.at(i), actual.at(i));
				Assert::AreEqual(expected.at(i), repeat.at(i));
			}
		}

		TEST_METHOD(TestEncryptCBC) 
		{
			std::vector<uint8_t> allZeros(16, 0);
			AmateurEncrypt encrypt(allZeros);

			std::vector<std::vector<uint8_t>> input = { allZeros, allZeros, allZeros };
			std::vector<std::vector<uint8_t>> actual = encrypt.cbc(input, allZeros);
			// The expected output was generated by a different AES implementation
			std::vector<std::vector<uint8_t>> expected{ {102, 233, 75, 212, 239, 138, 44, 59, 136, 76, 250, 89, 202, 52, 43, 46}, {247, 149, 189, 74, 82, 226, 158, 215, 19, 211, 19, 250, 32, 233, 141, 188}, {161, 12, 246, 109, 15, 221, 243, 64, 83, 112, 180, 191, 141, 245, 191, 179} };

			Assert::AreEqual(expected.size(), actual.size());
			for (int i = 0; i < expected.size(); ++i) {
				auto& exp = expected.at(i);
				auto& act = actual.at(i);
				for (int j = 0; j < 16; ++j) {
					Assert::AreEqual(exp.at(j), act.at(j));
				}
			}
		}

		TEST_METHOD(TestDecryptBlock) 
		{
			std::vector<uint8_t> key{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
			std::vector<uint8_t> block{ 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 };


			AmateurEncrypt encrypt(key);
			AmateurDecrypt decrypt(key);

			auto cipher = encrypt.encryptBlock(block);
			std::vector<uint8_t> roundTrip = decrypt.decryptBlock(cipher);
			Assert::AreEqual(block.size(), roundTrip.size());
			for (int i = 0; i < 16; ++i)
			{
				Assert::AreEqual(block.at(i), roundTrip.at(i));
			}
		}
	};
}